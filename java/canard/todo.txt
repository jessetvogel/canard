// - Make Prop different from Type, but so that when P : Prop, we can still make things out of P, e.g. 'p : P'

// - How to prevent circular searching ?
// Solution: introduce depth of queries

// - Set a maximum search depth!
//    - Measure depth differently! If it takes 5 depths to satisfy some proof, while the other proofs just carry over,
//    those other proofs have not really be attempted, so their depth doesn't really count!
//    Rather keep track of the depth of the indeterminants!

// - include files
//      - The obvious syntax is `include/import file`
//      - Or copy LEAN and use `import dir.subDir.file`
//          - At the moment we have `import "path-to-file.ext"`
//      - Probably prevent double imports ?
//        - Where do we keep track of what files are imported already? subParsers?
//            - Nope, not subParsers, rather a List<String> importedFiles that carries over

// - namespaces
//    - `namespace NAMESPACE ... end (NAMESPACE well, LEAN does it, so we probably do so as well?)`
//    - `open NAMESPACE`
//    - refer to definitions as NAMESPACE.object or something like that
//    - can namespaces be nested ?
//    - by what label are Function's now actually stored?

// - having multiple definitions have the same name/label ? (As long as their signature is not the same)
//    - Well LEAN does not support it, so why would we ?
//    - namespaces should suffice

// - aliases of some sort
//    - alias/set/def ideal (R : Ring) := submodule (RingAsModule R)
//    - def makes sense, in relation to LEAN. What do we use for def instead? `let` / `axiom` ?

// - Searching for indeterminants with dependencies.
//    - Could go with literal matches. Works in the easy cases
//    - Could go with a kind of subSearcher? I.e. we instantiate the dependencies and then search for the type.
//    If that succeeds, construct a lambda-thingy

// - Messaging system, support JSON format

// - Change comments to '-- comment' and '/- block comment -/' to match LEAN style

// - Create a '--explicit' option, which prints the namespace each time

// - Create a VSCode extension for synthax highlighting

// - 'not', and maybe further logic stuff

[ PRIORITY ! ]

- While searching, knowing when to break a branch!
    - If we ask a question that a parent is also asking (i.e. detecting a loop), just stop
    - How to do this ?
    - Compare a query to all of its parents. If the parent 'injects into the query', we can skip the query

[ LESS PRIORITY ]

- Maybe clean up Matcher.putSolution, while keeping the functionality
    - Can a child-matcher put solutions for the parent ??

- Re-use existing proofs

- variables like LEAN.  `variables {X Y : Scheme} {f : Morphism X Y}`. But seems quite difficult to implement!

- When the number of definitions is becomes large, use some **indexing system**.
  I.e. when we need `affine X`, already filter on all those functions which match `affine _`
  I.e. context has an additional map index<Function (base), List<Function>>. Then if possible, we can restrict to the indexed-list.
  Probably greatly improves speed!

- When can .specialze simply return the base ??

- Synthax for searching for multiple results
    - Currently is `search (..args..) <int>`, but seems ugly

- Preserve dependencies in duplicate when possible!

- Create a web interface
    - Home page
    - Explore/search page
    - Docs page #hash to encode what page

??- Move from Java to C++, so that we don't need a JVM, and maybe increase performance at some point ?
??    - Just learned about shared_ptr's, so might actually be doable to use C++ now

??- '--server <PORT>' option which starts a server at the given port
??    - Creates a parser object for each client, then just connect I/O


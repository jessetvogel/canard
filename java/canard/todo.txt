// - Make Prop different from Type, but so that when P : Prop, we can still make things out of P, e.g. 'p : P'

// - How to prevent circular searching ?
// Solution: introduce depth of queries

// - Set a maximum search depth!
//    - Measure depth differently! If it takes 5 depths to satisfy some proof, while the other proofs just carry over,
//    those other proofs have not really be attempted, so their depth doesn't really count!
//    Rather keep track of the depth of the indeterminants!

// - include files
//      - The obvious syntax is `include/import file`
//      - Or copy LEAN and use `import dir.subDir.file`
//          - At the moment we have `import "path-to-file.ext"`
//      - Probably prevent double imports ?
//        - Where do we keep track of what files are imported already? subParsers?
//            - Nope, not subParsers, rather a List<String> importedFiles that carries over

// - namespaces
//    - `namespace NAMESPACE ... end (NAMESPACE well, LEAN does it, so we probably do so as well?)`
//    - `open NAMESPACE`
//    - refer to definitions as NAMESPACE.object or something like that
//    - can namespaces be nested ?
//    - by what label are Function's now actually stored?

// - having multiple definitions have the same name/label ? (As long as their signature is not the same)
//    - Well LEAN does not support it, so why would we ?
//    - namespaces should suffice

// - aliases of some sort
//    - alias/set/def ideal (R : Ring) := submodule (RingAsModule R)
//    - def makes sense, in relation to LEAN. What do we use for def instead? `let` / `axiom` ?

// - Searching for indeterminants with dependencies.
//    - Could go with literal matches. Works in the easy cases
//    - Could go with a kind of subSearcher? I.e. we instantiate the dependencies and then search for the type.
//    If that succeeds, construct a lambda-thingy

- Re-use existing proofs

- 'not', and maybe further logic stuff

- variables like LEAN.  `variables {X Y : Scheme} {f : Morphism X Y}`. But seems quite difficult to implement!

- When the number of definitions is becomes large, use some indexing system.
  I.e. when we need `affine X`, already filter on all those functions which match `affine _`
  I.e. context has an additional map index<Function (base), List<Function>>. Then if possible, we can restrict to the indexed-list.
  Probably greatly improves speed!

- When can .specialze just return the base ??

- While searching, knowing when to break a branch! If we ask a question that a parent is also asking (i.e. detecting a loop), just stop

// - Messaging system, support JSON format

- Synthax for searching for multiple results
    - Currently is `search (..args..) <int>`

- Preserve dependencies in duplicate when possible!

# Type definitions
let Ring : Type
let Module (R : Ring) : Type
let Scheme : Type

let Morphism {T : Type} (X Y : T) : Type # Maybe a bit too general

# Constructions
let Spec (R : Ring) : Scheme
let RingAsModule (R : Ring) : Module R
let id {T : Type} (X : T) : Morphism X X

# Ring properties
let field artin r_noetherian r_local gorenstein euclidean r_reduced (R : Ring) : Prop
let ideal (R : Ring) : Type
let maximal_ideal prime_ideal radical_ideal {R : Ring} (I : ideal R) : Prop
let nilradical zero_ideal unit_ideal jacobson_radical (R : Ring) : ideal R

# Scheme properties
let affine quasi_compact regular noetherian locally_noetherian reduced irreducible cohen_macaulay excellent separated quasi_separated jacobson normal integral finite_dimensional connected
    (X : Scheme) : Prop
let isomorphism formally_etale formally_unramified formally_smooth proper finite quasi_finite flat m_affine m_quasi_compact m_separated m_quasi_separated m_regular finite_presentation locally_finite_type locally_finite_presentation etale smooth unramified finite_type open universally_closed immersion open_immersion closed_immersion finite_fibers surjective zariski_cover etale_cover smooth_cover syntomic_cover fppf_cover fpqc_cover faithfully_flat
    {X Y : Scheme} (f : Morphism X Y) : Prop

# Examples
let ZZ QQ RR CC: Ring

# Theorems on schemes
let aff_imp_qcomp {X : Scheme} (h : affine X) : quasi_compact X
let reg_imp_lnoeth {X : Scheme} (h : regular X) : locally_noetherian X
let lnoeth_qcomp_imp_noeth {X : Scheme} (h1 : locally_noetherian X) (h2 : quasi_compact X) : noetherian X
let noeth_imp_lnoeth {X : Scheme} (h1 : noetherian X) : locally_noetherian X
let noeth_imp_qcomp {X : Scheme} (h1 : noetherian X) : quasi_compact X
let int_imp_red {X : Scheme} (h : integral X) : reduced X
let int_imp_irred {X : Scheme} (h : integral X) : irreducible X
let red_irred_imp_int {X : Scheme} (h1 : reduced X) (h2 : irreducible X) : integral X
let reg_imp_cohmac {X : Scheme} (h : regular X) : cohen_macaulay X
let int_imp_conn {X : Scheme} (h : integral X) : connected X
let reg_imp_red {X : Scheme} (h : regular X) : reduced X
let aff_imp_sep {X : Scheme} (h : affine X) : separated X
let sep_imp_qsep {X : Scheme} (h : separated X) : quasi_separated X
let lnoeth_imp_qsep {X : Scheme} (h : locally_noetherian X) : quasi_separated X
let irr_imp_conn {X : Scheme} (h : irreducible X) : connected X
let cohmac_imp_lnoeth {X : Scheme} (h : cohen_macaulay X) : locally_noetherian X
let reg_imp_nor {X : Scheme} (h : regular X) : normal X

# Theorems on scheme morphisms
let fsmooth_lfp_imp_smooth {X Y : Scheme} {f : Morphism X Y} (h1 : formally_smooth f) (h2 : locally_finite_presentation f) : smooth f
let smooth_imp_fsmooth {X Y : Scheme} {f : Morphism X Y} (h : smooth f) : formally_smooth f
let smooth_imp_lfp {X Y : Scheme} {f : Morphism X Y} (h : smooth f) : locally_finite_presentation f

let fetale_lfp_imp_etale {X Y : Scheme} {f : Morphism X Y} (h1 : formally_etale f) (h2 : locally_finite_presentation f) : etale f
let etale_imp_fetale {X Y : Scheme} {f : Morphism X Y} (h : etale f) : formally_etale f
let etale_imp_lfp {X Y : Scheme} {f : Morphism X Y} (h : etale f) : locally_finite_presentation f

let funram_lft_imp_unram {X Y : Scheme} {f : Morphism X Y} (h1 : formally_unramified f) (h2 : locally_finite_type f) : unramified f
let unram_imp_funram {X Y : Scheme} {f : Morphism X Y} (h : unramified f) : formally_unramified f
let unram_imp_lft {X Y : Scheme} {f : Morphism X Y} (h : unramified f) : locally_finite_type f

let fetale_imp_fsmooth {X Y : Scheme} {f : Morphism X Y} (h : formally_etale f) : formally_smooth f
let fetale_imp_funram {X Y : Scheme} {f : Morphism X Y} (h : formally_etale f) : formally_unramified f
let fsmooth_funram_imp_fetale {X Y : Scheme} {f : Morphism X Y} (h1 : formally_smooth f) (h2 : formally_unramified f) : formally_etale f

let lfp_qsep_qcomp_imp_fp {X Y : Scheme} {f : Morphism X Y} (h1 : locally_finite_presentation f) (h2 : m_quasi_separated f) (h3 : m_quasi_compact f) : finite_presentation f
let lfp_imp_lft {X Y : Scheme} {f : Morphism X Y} (h : locally_finite_presentation f) : locally_finite_type f
let fp_imp_ft {X Y : Scheme} {f : Morphism X Y} (h : finite_presentation f) : finite_type f
let lft_qcomp_imp_ft {X Y : Scheme} {f : Morphism X Y} (h1 : locally_finite_type f) (h2 : m_quasi_compact f) : finite_type f

let ft_imp_lft {X Y : Scheme} {f : Morphism X Y} (h : finite_type f) : locally_finite_type f
let ft_imp_qcomp {X Y : Scheme} {f : Morphism X Y} (h : finite_type f) : m_quasi_compact f

let aff_imp_comp_morph {X Y : Scheme} {f : Morphism X Y} (h : m_affine f) : m_quasi_compact f

let fin_imp_aff {X Y : Scheme} {f : Morphism X Y} (h : finite f) : m_affine f
let fin_imp_prop {X Y : Scheme} {f : Morphism X Y} (h : finite f) : proper f
let aff_prop_imp_fin {X Y : Scheme} {f : Morphism X Y} (h1 : m_affine f) (h2 : proper f): finite f

let flat_lfp_imp_open {X Y : Scheme} {f : Morphism X Y} (h1 : flat f) (h2 : locally_finite_presentation f) : open f

let ft_univcl_sep_imp_prop {X Y : Scheme} {f : Morphism X Y} (h1 : finite_type f) (h2: universally_closed f) (h3 : m_separated f) : proper f
let prop_imp_ft {X Y : Scheme} {f : Morphism X Y} (h : proper f) : finite_type f
let prop_imp_univcl {X Y : Scheme} {f : Morphism X Y} (h : proper f) : universally_closed f
let prop_imp_sep {X Y : Scheme} {f : Morphism X Y} (h : proper f) : m_separated f
let lft_lnoeth_imp_lfp {X Y : Scheme} {f : Morphism X Y} (h1 : locally_finite_type f) (h2 : locally_noetherian Y) : locally_finite_presentation f
let univcl_imp_qcomp {X Y : Scheme} {f : Morphism X Y} (h : universally_closed f) : m_quasi_compact f
let climm_imp_prop {X Y : Scheme} {f : Morphism X Y} (h : closed_immersion f) : proper f
let lft_lnoeth_imp_qsep {X Y : Scheme} {f : Morphism X Y} (h1 : locally_finite_type f) (h2 : locally_noetherian Y) : m_quasi_separated f
let climm_ft {X Y : Scheme} {f : Morphism X Y} (h : closed_immersion f) : finite_type f
let imm_lnoeth_imp_qcomp {X Y : Scheme} {f : Morphism X Y} (h1 : immersion f) (h2 : locally_noetherian Y) : m_quasi_compact f
let src_noeth_imp_qcomp {X Y : Scheme} (f : Morphism X Y) (h : noetherian X) : m_quasi_compact f
let sep_imp_qsep_morph {X Y : Scheme} {f : Morphism X Y} (h : m_separated f) : m_quasi_separated f
let qfin_imp_qcomp {X Y : Scheme} {f : Morphism X Y} (h : quasi_finite f) : m_quasi_compact f
let qfin_imp_finfib {X Y : Scheme} {f : Morphism X Y} (h : quasi_finite f) : finite_fibers f
let qcomp_finfib_imp_qfin {X Y : Scheme} {f : Morphism X Y} (h1 : m_quasi_compact f) (h2 : finite_fibers f) : quasi_finite f
let op_imm_imp_etale {X Y : Scheme} {f : Morphism X Y} (h : open_immersion f) : etale f
let op_imm_imp_sep {X Y : Scheme} {f : Morphism X Y} (h : open_immersion f) : m_separated f
let flat_surj_imp_fflat {X Y : Scheme} {f : Morphism X Y} (h1 : flat f) (h2 : surjective f) : faithfully_flat f
let fflat_imp_flat {X Y : Scheme} {f : Morphism X Y} (h : faithfully_flat f) : flat f
let fflat_imp_surj {X Y : Scheme} {f : Morphism X Y} (h : faithfully_flat f) : surjective f
let aff_imp_sep_morph {X Y : Scheme} {f : Morphism X Y} (h : m_affine f) : m_separated f
let fin_imp_qfin {X Y : Scheme} {f : Morphism X Y} (h : finite f) : quasi_finite f

# Examples
let SpecIsAffine (R : Ring) : affine (Spec R)
let ZZIntegral : integral (Spec ZZ)

let QQIsField : field QQ
let RRIsField : field RR
let CCIsField : field CC


# Checks
check red_irred_imp_int (int_imp_red ZZIntegral) (int_imp_irred ZZIntegral) ;

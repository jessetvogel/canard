import "../set_theory/set.cnd"
import "../group_theory/group.cnd"
open set_theory.set

namespace commutative_algebra
namespace ring
    -- The type of commutative rings.
    let Ring : Type
    -- The underlying set of a ring $R$.
    let set (R : Ring) : Set
    -- A ring $R$ is trivial if it consists of a single element, that is, $R \simeq \{ 0 \}$.
    let trivial (R : Ring) : Prop
    -- A non-trivial ring $R$ is a domain if it has no zero-divisors. That is, $ab = 0$ implies $a = 0$ or $b = 0$ for all $a, b \in R$.
    let domain (R : Ring) : Prop
    -- A ring $R$ is a field if $1 \ne 0$ and every non-zero element is invertible.
    let field (R : Ring) : Prop
    /- A ring $R$ is artin if it satsifies the descending chain condition: for any decreasing sequence of ideals
    \[ I_1 \supset I_2 \supset I_3 \supset \cdots \]
    there exists some $N \in \NN$ such that $I_n = I_N$ for all $n \ge N$. -/
    let artin (R : Ring) : Prop
    /- A ring $R$ is noetherian if it satisfies the ascending chain condition: for any increasing sequence of ideals
    \[ I_1 \subset I_2 \subset I_3 \subset \cdots \]
    there exists $N \in \NN$ such that $I_n = I_N$ for any $n \ge N$.
    Equivalently, $R$ is noetherian if all its ideals are finitely generated. -/
    let noetherian (R : Ring) : Prop
    let local (R : Ring) : Prop
    let gorenstein (R : Ring) : Prop
    let euclidean (R : Ring) : Prop
    -- A ring is reduced if it has no non-zero nilpotent elements.
    let reduced (R : Ring) : Prop
    let valuation (R : Ring) : Prop
    let dvr (R : Ring) : Prop
    -- A ring is finite if it contains finitely many elements.
    let finite (R : Ring) : Prop
    let dedekind (R : Ring) : Prop
    -- A ring $R$ is integrally closed if it contains all elements in its field of fraction that are integral over $R$.
    let integrally_closed (R : Ring) : Prop
    let ufd (R : Ring) : Prop
    -- A ring $R$ is a PID if every ideal in $R$ is of the form $(x)$ for an element $x \in R$.
    let pid (R : Ring) : Prop
    let jacobson (R : Ring) : Prop
    let complete (R : Ring) : Prop
    let excellent (R : Ring) : Prop
    let ideal (R : Ring) : Type -- define as a submodule of module_self R ? 
    -- An ideal $I$ of a ring $R$ is maximal if $I \ne R$ and if $I \subset J \subsetneq R$ implies $I = J$ for any other ideal $J \subset R$.
    let maximal_ideal {R : Ring} (I : ideal R) : Prop
    -- An ideal $I$ of a ring $R$ is prime if $I \ne R$ and $xy \in I$ implies $a \in I$ or $b \in I$.
    let prime_ideal {R : Ring} (I : ideal R) : Prop
    -- An ideal $I$ of a ring $R$ is radical if $x^n \in I$ for some $x \in R$ and $n \ge 1$ implies $x \in I$.
    let radical_ideal {R : Ring} (I : ideal R) : Prop
    let nilradical zero_ideal unit_ideal jacobson_radical (R : Ring) : ideal R
end ring
open commutative_algebra.ring

-- Module properties
namespace module
    -- The type of modules over a given ring $R$.
    let Module (R : Ring) : Type
    -- An $R$-module $M$ is finitely generated if there exist elements $m_1, m_2, \ldots, m_n \in M$ (called generators) such that \[ M = R m_1 + R m_2 + \cdots R m_n . \]
    let finitely_generated {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is cyclic if it can be generated by one element, that is $M = R m$ for some $m \in M$.
    let cyclic {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is free if it is isomorphic to a direct sum $\bigoplus_{i \in I} R$ for some indexing set $I$.
    let free {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is projective if the functor $\Hom_R(M, -)$ is exact.
    let projective {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is injective if the functor $\Hom_R(-, M)$ is exact.
    let injective {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is flat if the functor $(-) \otimes_R M$ is exact.
    let flat {R : Ring} (M : Module R) : Prop
    -- A non-zero $R$-module $M$ is simple if it has no non-zero proper submodules.
    let simple {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is semisimple if it is isomorphic to a direct sum of simple modules.
    let semisimple {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is indecomposable if it cannot be written as the direct sum of two non-zero proper submodules.
    let indecomposable {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is faithful if $r \cdot M = 0$ implies 
    let faithful {R : Ring} (M : Module R) : Prop
    -- An $R$-module $M$ is torsion-free if $rm = 0$ implies $r = 0$ or $m = 0$, for all $r \in R$ and $m \in M$.
    let torsion_free {R : Ring} (M : Module R) : Prop
    /- An $R$-module $M$ is noetherian if it it satisfies the ascending chain condition: for any increasing sequence of submodules
    \[ M_1 \subset M_2 \subset M_3 \subset \cdots \]
    there exists some $N \in \NN$ such that $M_n = M_N$ for any $n \ge N$. -/
    let noetherian {R : Ring} (M : Module R) : Prop
    /- An $R$-module $M$ is noetherian if it satisfies the \textit{descending chain condition}: for any decreasing sequence of submodules
    \[ M_1 \supset M_2 \supset M_3 \supset \cdots \]
    there exists some $N \in \NN$ such that $M_n = M_N$ for any $n \ge N$. -/
    let artin {R : Ring} (M : Module R) : Prop
end module
open commutative_algebra.module

namespace ring
    -- Any ring morphism $f : R \to S$ makes $S$ into an $R$-module.
    let module_of_ring_morphism {R S : Ring} (f : Morphism R S) : Module R
    -- Any ring is a module over itself.
    def module_self (R : Ring) := module_of_ring_morphism (id R)
end ring

-- The type of algebras over a given ring $R$.
-- let Algebra (R : Ring) : Type -- Although actually, can we define an Algebra as a `Morphism R _` ?
-- let algebra_of_ring_morphism {R S : Ring} (f : Morphism R S) : Algebra R
-- def algebra_self (R : Ring) := algebra_of_ring_morphism (id R)
-- let module_of_algebra {R : Ring} (A : Algebra R) : Module R

open group_theory.group
-- The multiplicative group $R^*$ of a commutative ring $R$.
let mult_group (R : Ring) : Group
-- The multiplicative group $R^*$ of a commutative ring $R$ is abelian.
let mult_group_ab (R : Ring) : abelian (mult_group R)
-- The map $R \mapsto R^*$ defines a functor from commutative rings to groups.
let mult_group_functor : functor mult_group

end commutative_algebra

import "/Users/jessevogel/Projects/canard/math/main.cnd"

-- Performance check: search (A B C D E F G H I J : Scheme) and profiler

open algebraic_geometry;
open algebraic_geometry.scheme;
open algebraic_geometry.morphism;
open commutative_algebra;
open commutative_algebra.ring;

search (R : Ring);

search (X : Scheme) (h : scheme.affine X);
search (X : Scheme) (h : scheme.affine X) (q : scheme.quasi_compact X);

search (P (X : Scheme) (h : scheme.affine X) : scheme.quasi_compact X);
search (P (X : Scheme) (h : scheme.affine X) : scheme.quasi_separated X);
search (P (X : Scheme) (h : scheme.affine X) : morphism.affine (id X) );
search (P (X : Scheme) (h : scheme.affine X) : morphism.quasi_compact (id X) );
search (P {X Y : Scheme} {f : Morphism X Y} (h : closed_immersion f) : locally_finite_type f) ;
search (P {X Y Z: Scheme} {f : Morphism X Y} {g : Morphism Y Z} (fProper : proper f) (gProper : proper g) : proper (comp g f));
search (P {X Y Z: Scheme} {f : Morphism X Y} {g : Morphism Y Z} (fFinite : morphism.finite f) (gFinite : morphism.finite g) : proper (comp g f));

search (P {A B : Prop} (h (a : A) : B) (x : A) : B) ;
search (P {A B : Prop} (h (a : A) : B) (a1 : A) (a2 : A) : B) ;
search (P {A B : Prop} (h (a : A) : B) (nb : not B) : not A) ;
search (P (X: Scheme) (h : not (scheme.quasi_compact X)) : not (scheme.affine X));
search (P {X Y : Scheme} {f : Morphism X Y} (h : not (universally_closed f)) : not(proper f));

search (P {X Y: Scheme} {f : Morphism X Y} (h : not (unramified f)) : not (etale f));
def unram_of_et {X Y : Scheme} {f : Morphism X Y} (h : etale f) := ur_of_fur_lft (fur_of_fet (fet_of_et h)) (lft_of_lfp (lfp_of_et h))
search (P {X Y: Scheme} {f : Morphism X Y} (h : not (unramified f)) : not (etale f));
search (P {X Y: Scheme} {f : Morphism X Y} (h : etale f) : unramified f);

search (P : locally_noetherian (affine_line (Spec QQ)))

search (X : Scheme) (h1 : scheme.affine X) (h2 : scheme.quasi_compact X);
search (X : Scheme) (h : integral X);
search (R : Ring) (h : integral (Spec R));
search (X Y : Scheme) (f : Morphism X Y);
search (R : Ring) (M N : Module R) (f : Morphism M N);
search (R : Ring) (M : Module R) (h1 : module.flat M) (h2 : not (module.free M));
search (P {U V W : Scheme} {g : Morphism U V} {h : Morphism V W} (gClosedImm : closed_immersion g) (hClosedImm : closed_immersion h) : proper (comp h g));
